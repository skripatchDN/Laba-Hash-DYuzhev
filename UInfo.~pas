{
Задача 4b Хеширование
Задан набор записей следующей структуры: табельный номер, ФИО, заработная плата.
По табельному номеру найти остальные сведения.

В папке проекта уже есть файл для тестирования: test.txt
}
unit UInfo;

interface

uses Classes, SysUtils;

const
  NAMES: array[0..11] of string = ('Волчуков', 'Деркачев', 'Дюжев',
                                    'Зайцев', 'Карташов', 'Кустовинов',
                                    'Лейба', 'Макатовчук', 'Малюгин',
                                    'Микляев', 'Михайлов', 'Наумов');
  SECOND_NAMES: array[0..11] of string = ('Анатолий', 'Антон', 'Борис',
                                    'Виталий', 'Владислав', 'Григорий',
                                    'Егор', 'Иван', 'Никита',
                                    'Николай', 'Олег', 'Петр');
  PATRONYMICS: array[0..11] of string = ('Александрович', 'Алексеевич', 'Анатольевич',
                                    'Андреевич', 'Антонович', 'Аркадьевич',
                                    'Артемович', 'Бедросович', 'Богданович',
                                    'Борисович', 'Валентинович', 'Васильевич');

type
  TKey = integer;
  TInfo = class
    FKey : TKey;         // табельный номер
    FName : string;      // ФИО
    FSalary: integer;    // заработная плата

    function HF(key : TKey) : integer;
    function IsEqualKey (k1, k2 : TKey) : boolean;
    procedure SaveToFile(var f : TextFile; info: TInfo);
    function LoadFromFile(var f : TextFile; var info : TInfo) : boolean;
    procedure ShowInfo(info : TInfo; Row : TStrings);
    function GetInfo(key: TKey; name: string; salary: integer): TInfo;
    function RandomInfo: TInfo;
  end;



implementation

// хэш-функция
function TInfo.HF(): integer;
begin
  Result := FKey;     // ключом является табельный номер, который обычно уникален
                      // поэтому целесообразно его и использовать в качестве h(k)
end;

// сравнение с ключом k2
function IsEqualKey (k2 : TKey) : boolean;
begin
  Result := FKey = k2;
end;

// загрузка инфы из файла
// f - текстовый файл, info - туда кладется считанная запись
// возвращает, удалось ли считать запись
function LoadFromFile(var f: TextFile): boolean;
var
  tmp: string;
begin
  Result := not eof(f);
  if Result then
    begin
      readln(f, tmp);
      while (tmp = '') and not eof(f) do
        readln(f, tmp);
      Result := TryStrToInt(tmp, FKey) and
                (FKey >= 0) and
                not eof(f);
      if Result then
        begin
          readln(f, FName);
          Result := (FName <> '') and not eof(f);
          if Result then
            begin
              readln(f, tmp);
              Result := (tmp <> '') and
              TryStrToInt(tmp, FSalary) and
              (FSalary >= 0);
            end;
        end;
    end;
end;

// сохранение инфы в файл
// f - текстовый файл, info - запись
procedure SaveToFile(var f: TextFile);
begin
  writeln(f, FKey);
  writeln(f, FName);
  writeln(f, FSalary);
  writeln(f);
end;

// добавление инфы в TStrings
procedure ShowInfo(Row: TStrings);
begin
  //Row.Add(info.name)
end;

// возвращает инфу по данным
constructor Create(key: TKey; name: string; salary: integer);
begin
  FKey := key;
  FName := name;
  FSalary := salary;
end;

function RandomInfo;
begin
  randomize();
  FKey := random(1000) + 1;
  FName := NAMES[random(12)] + ' ' +
                SECOND_NAMES[random(12)] + ' ' +
                PATRONYMICS[random(12)];
  FSalary := (random(30) + 3) * 5000;

end;

end.
