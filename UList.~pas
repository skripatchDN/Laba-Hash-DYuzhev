unit UList;

interface

uses UInfo, Grids;

type
  TPointer = ^TNode;
  TNode = record
    info: TInfo;
    next: TPointer;
  end;

  TList = class
    private
      FHead: TPointer;
    protected
      function AddNode(var p: TPointer; inf: TInfo): TPointer;
      procedure DelNode(var p: TPointer);
      function GetNode(key: TKey; var p: TPointer): TPointer;
    public
      constructor Create;
      destructor Destroy; override;
      procedure Clear;
      function Add(inf: TInfo): boolean;
      function Find(key: TKey; var inf: TInfo): boolean;
      function Delete(key: TKey): boolean;
      procedure SaveToFile(var f: TextFile);
      procedure View(SG: TStringGrid; var index: integer);
  end;

implementation


{ TList }

// Добавление элемента в список
// Возвращает, добавлен ли элемент
function TList.Add(inf: TInfo): boolean;
var
  t, p: TPointer;
begin
  t := GetNode(inf.key, p);
  Result := t = nil;
  if Result then
    if FHead = nil then
      AddNode(FHead, inf)
    else
      AddNode(p.next, inf);
end;

// Добавление узла перед p
// Возвращает указатель на созданный узел
// p после выполнения функции указывает на добавленный узел для удобства
function TList.AddNode(var p: TPointer; inf: TInfo): TPointer;
begin
  new(result);
  result.info := inf;
  result.next := p;
  p := result;
end;

// очистка списка
procedure TList.Clear;
begin
  while FHead <> nil do
    DelNode(FHead)
end;

// создание списка
constructor TList.Create;
begin
  FHead := nil
end;

// Удаление ключа из списка
// Возвращает, удален ли ключ
function TList.Delete(key: TKey): boolean;
var
  t, p: TPointer;
begin
  t := GetNode(key, p);
  Result := t <> nil;
  if Result then
    if p = nil then
      DelNode(FHead)
    else
      DelNode(p.next);
end;

// Удаляет узел списка
procedure TList.DelNode(var p: TPointer);
var t: TPointer;
begin
  t:= p;
  p:= p.Next;
  dispose(t);
end;

// уничтожение списка
destructor TList.Destroy;
begin
  Clear;
  inherited;
end;

// поиск ключа
// если найден, возвращает true и кладет инфу в inf
function TList.Find(key: TKey; var inf: TInfo): boolean;
var
  t, p: TPointer;
begin
  t := GetNode(key, p);
  result := t <> nil;
  if result then
    inf := t.info;
end;

// возвращает узел по ключу, p - предыдущий узел списка,
// указывающий на узел с ключом
function TList.GetNode(key: TKey; var p: TPointer): TPointer;
var
  ok: boolean;
begin
  p := nil;
  Result := FHead;
  ok := false;
  while (Result <> nil) and (not ok) do
    if IsEqualKey(key, Result.info.key) then
      ok := true
    else
      begin
        p := Result;
        Result := Result.next;
      end;
end;

// сохранение списка в файл
procedure TList.SaveToFile(var f: TextFile);
var
  t: TPointer;
begin
  t := FHead;
  while t <> nil do
    begin
      UInfo.SaveToFile(f, t.info);
      t := t.next;
    end;
end;

// Вывод списка в TStringGrid
procedure TList.View(SG: TStringGrid; var index: integer);
var
  t: TPointer;
begin
  t:= FHead;
  if t <> nil then
    inc(index);
  while t <> nil do
    begin
      ShowInfo(t.info, SG.Rows[index]);
      t:= t^.next;
    end;
end;

end.
