unit UHashTable;

interface
uses
  UList, UInfo, Grids, SysUtils;

const
  N = 101;

type
  TIndex = 0..N-1;
  TCell = TList;
  TTable = array[TIndex] of TCell;
  THashFunction = function(key: TKey): integer;

  THashTable = class
  private
    FTable: TTable;
    FCount: integer;
  protected
    function HashF(key: TKey): TIndex;
  public
    constructor Create;
    destructor Destroy; override;
    procedure Clear; virtual;
    function Add(info: TInfo): boolean; virtual;
    function Find(key: TKey; var info: TInfo): boolean;
    function Delete(key: TKey): boolean; virtual;
    function LoadFromFile(FileName: string): boolean;
    procedure AddRandom(n: integer);
    procedure SaveToFile(FileName: string);
    procedure View(SG: TStringGrid);
    property Count: integer read FCount;
  end;
implementation



{ THashTable }

// добавление в таблицу, возвращает добавлен ли элемент
// info - запись добавляемой инфы
function THashTable.Add(info: TInfo): boolean;
var
  pos: TIndex;
begin
  pos := HashF(info.key);
  Result := FTable[pos].Add(info);
  if Result then
    inc(Fcount);
end;

// добавление n случайных записей в талицу
procedure THashTable.AddRandom(n: integer);
var
  i: integer;
begin
  for i:=1 to n do
    Add(RandomInfo());
end;

// очистка таблицы
procedure THashTable.Clear;
var
  i: integer;
begin
  if FCount > 0 then
    begin
      for i := 0 to N-1 do
      FTable[i].Clear;
      FCount := 0;
    end;
end;

// конструктор таблицы
constructor THashTable.Create;
var
  i: TIndex;
begin
  inherited Create;
  for i  := 0 to N-1 do
    FTable[i] := TList.Create;
  FCount := 0;
end;

// удалить элемент, возращает: удален ли
function THashTable.Delete(key: TKey): boolean;
begin
  Result := FTable[HashF(key)].Delete(Key);
  if Result then
    dec(FCount);end;

// деструктор таблицы
destructor THashTable.Destroy;
var
  i: TIndex;
begin
  for i:=0 to N-1 do
    FreeAndNil(FTable[i]);
  inherited;
end;

// поиск ключа key в таблице,
// если найден то возвращает true и в info записывает значение
function THashTable.Find(key: TKey; var info: TInfo): boolean;
begin
  Result := FTable[HashF(key)].Find(key, info);
end;

// хэш-функция, возвращает позицию элемента в таблице
function THashTable.HashF(key: TKey): TIndex;
begin
  Result := HF(key) mod N
end;


// чтение хеш-таблицы из файла, возращает, удалось ли загрузить
// FileName - имя читаемого файла
function THashTable.LoadFromFile(FileName: string): boolean;
var
  f: TextFile;
  info: TInfo;
begin
  Result := true;
  AssignFile(f, FileName);
  Reset(f);
  Clear;
  while (not eof(F) and Result) do
    begin
      if UInfo.LoadFromFile(f, info) then
        Result := Add(info)
      else
        Result := false;
    end;
  CloseFile(f);
end;
// сохранение таблицы в файл
// FileName - имя файла
procedure THashTable.SaveToFile(FileName: string);
var
  i: integer;
  f: TextFile;
begin
  AssignFile(f, FileName);
  Rewrite(f);
  if FCount > 0 then
    for i := 0 to N-1 do
      FTable[i].SaveToFile(f);
  CloseFile(f);
end;

// вывод таблицы в StringGrid
procedure THashTable.View(SG: TStringGrid);
var
  i, index: integer;
begin
  with SG do
    for i:=0 to ColCount-1 do
      Cols[i].Clear;
  if FCount = 0 then
    begin
      SG.RowCount := 2;
      SG.Rows[1].Clear;
    end
  else
    begin
      index := 0;
      SG.RowCount := FCount + 1;
      for i := 0 to N-1 do
        FTable[i].View(SG, index);
    end;
end;
end.
